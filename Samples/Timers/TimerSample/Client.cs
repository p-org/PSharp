// ------------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License (MIT). See License.txt in the repo root for license information.
// ------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.PSharp;
using Microsoft.PSharp.Timers;
using System.Threading.Tasks;

namespace TimerSample
{
	class Client : TimedMachine
	{
		#region fields
		/// <summary>
		/// Count of #timeout events processed per state.
		/// </summary>
		int count;

		/// <summary>
		/// A dummy payload object received with timeout events.
		/// </summary>
		object payload = new object();

		/// <summary>
		/// Timer used in the Ping State.
		/// </summary>
		TimerId pingTimer;

		/// <summary>
		/// Timer used in the Pong state.
		/// </summary>
		TimerId pongTimer;

		#endregion

		#region states

		/// <summary>
		/// Start the pingTimer and start handling the timeout events from it.
		/// After handling 10 events, stop pingTimer and move to the Pong state.
		/// </summary>
		[Start]
		[OnEntry(nameof(DoPing))]
		[OnEventDoAction(typeof(TimerElapsedEvent), nameof(HandleTimeoutForPing))]
		class Ping : MachineState { }

		/// <summary>
		/// Start the pongTimer and start handling the timeout events from it.
		/// After handling 10 events, stop pongTimer and move to the Ping state.
		/// </summary>
		[OnEntry(nameof(DoPong))]
		[OnEventDoAction(typeof(TimerElapsedEvent), nameof(HandleTimeoutForPong))]
		class Pong : MachineState { }
		#endregion

		#region event handlers

		private void DoPing()
		{
			// reset the count
			count = 1;

			// Start a periodic timer with timeout interval of 1sec.
			// The timer generates TimerElapsedEvent with 'm' as payload.
			pingTimer = StartTimer(payload, 50, true);
		}

		/// <summary>
		/// Handle timeout events from the pingTimer.
		/// </summary>
		private async Task HandleTimeoutForPing()
		{
			TimerElapsedEvent e = (this.ReceivedEvent as TimerElapsedEvent);

			// Ensure that we are handling a valid timeout event.
			this.Assert(e.Tid == this.pingTimer, "Handling timeout event from an invalid timer.");

			this.Logger.WriteLine("ping count: {0}", count);

			// Extract the payload
			Object payload = e.Tid.Payload;

			// Increment the count
			count++;

			// Halt pingTimer after handling 10 timeout events
			if (count == 10)
			{
				// Stop the pingTimer, and flush the inbox of all timeout events generated by it
				await StopTimer(pingTimer, flush: true);
				this.Goto<Pong>();
			}
		}

		/// <summary>
		/// Handle timeout events from the pongTimer.
		/// </summary>
		private void DoPong()
		{
			// reset the count
			count = 1;

			// Start a periodic timer with timeout interval of 0.5sec.
			// The timer generates TimerElapsedEvent with 'm' as payload.
			pongTimer = StartTimer(payload, 50, true);
		}

		private async Task HandleTimeoutForPong()
		{
			TimerElapsedEvent e = (this.ReceivedEvent as TimerElapsedEvent);

			// Ensure that we are handling a valid timeout event.
			this.Assert(e.Tid == this.pongTimer, "Handling timeout event from an invalid timer.");

			this.Logger.WriteLine("pong count: {0}", count);

			// Extract the payload
			Object payload = e.Tid.Payload;

			// Increment the count
			count++;

			// Halt pingTimer after handling 10 timeout events
			if (count == 10)
			{
				// Stop the pingTimer, and flush the inbox of all timeout events generated by it
				await StopTimer(pongTimer, flush: true);
				this.Goto<Ping>();
			}
		}
		#endregion
	}
}
