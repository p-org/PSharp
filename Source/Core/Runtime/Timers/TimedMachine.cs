// ------------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License (MIT). See License.txt in the repo root for license information.
// ------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Microsoft.PSharp.Timers
{
    /// <summary>
    /// Extends the P# Machine with a simple timer.
    /// </summary>
    public abstract class TimedMachine : Machine
    {
        /// <summary>
        /// Set of currently active timers.
        /// </summary>
        HashSet<TimerId> timers = new HashSet<TimerId>();

        /// <summary>
        /// Start a timer.
        /// </summary>
        /// <param name="payload">Payload of the timeout event.</param>
        /// <param name="IsPeriodic">Specifies whether a periodic timer is desired.</param>
        /// <param name="period">Periodicity of the timeout events in ms.</param>
        /// <returns>The id of the created timer.</returns>
        protected TimerId StartTimer(object payload, int period, bool IsPeriodic)
        {
            // The specified period must be valid
            this.Assert(period >= 0, "Timer period must be non-negative");

            var mid = this.Runtime.CreateMachineId(this.Runtime.GetTimerMachineType());
            var tid = new TimerId(mid, payload);

            this.Runtime.CreateMachine(mid, this.Runtime.GetTimerMachineType(), new InitTimer(this.Id, tid, IsPeriodic, period));

            timers.Add(tid);
            return tid;
        }

        /// <summary>
        /// Stop the timer.
        /// </summary>
        /// <param name="timer">Id of the timer machine which is being stopped.</param>
        /// <param name="flush">Clear the queue of all timeout events generated by "timer".</param>
        protected async Task StopTimer(TimerId timer, bool flush = true)
        {
            // Check if the user is indeed trying to halt a valid timer
            this.Assert(timers.Contains(timer), "Illegal timer-id given to StopTimer");
            timers.Remove(timer);

            this.Send(timer.mid, new HaltTimerEvent(this.Id, flush));

            // Flush the buffer: the timer being stopped sends a markup event to the inbox of this machine.
            // Keep dequeuing eTimeout events (with payload being the timer being stopped), until we see the markup event.
            if (flush)
            {
                while (true)
                {
                    var ev = await this.Receive(Tuple.Create(typeof(Markup), new Func<Event, bool>(e => true)),
                        Tuple.Create(typeof(TimerElapsedEvent), new Func<Event, bool>(e => (e as TimerElapsedEvent).Tid == timer)));

                    if (ev is Markup)
                    {
                        break;
                    }
                }
            }
        }
    }
}
